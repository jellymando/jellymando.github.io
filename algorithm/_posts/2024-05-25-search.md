---
layout: post
title: "[알고리즘] 탐색1"
sitemap: false
---

{:toc .large-only}

## 일반 탐색

### 순차 탐색

- 배열을 처음부터 순차적으로 찾는 방식
- 삽입 : 리스트의 맨 뒤에 원소를 추가
- 삭제 : 탐색으로 원소의 위치를 찾은 후 배열에서 삭제하고, 배열의 마지막 원소를 삭제된 자리로 이동한다.
- 정렬되지 않고 크기가 작은 데이터에 적합하다.

### 시간복잡도

- 탐색, 삭제 : O(n)
- 삽입 : O(1)

### 이진 탐색

- 정렬된 배열을 절반씩 줄여가면서 원소를 찾는 방식
- 배열의 가운데 원소를 기준으로 왼쪽, 오른쪽 부분배열로 나누어서 배열의 가운데 원소가 탐색 키보다 크면 왼쪽 배열에, 작으면 오른쪽 배열에 이진 탐색을 순환 호출한다.
- 초기화 : 주어진 배열이 정렬되어 있지 않으면 정렬 수행
- 삽입 : 탐색으로 원소를 올바른 위치에 삽입한 후 해당 위치에서부터 모든 원소를 한 칸씩 뒤로 이동한다.
- 삭제 : 탐색으로 원소의 위치를 찾은 후 배열에서 삭제하고, 해당 위치에서부터 모든 원소를 한 칸씩 앞으로 이동한다.
- 정렬되고 크기가 작은 데이터에 적합하다.
- 삽입과 삭제가 빈번한 경우에는 부적합하다.

#### 시간복잡도

- 초기화 : O(nlogn) (배열이 정렬되어 있는지 확인하고 정렬되어 있지 않으면 정렬 수행)
- 탐색 : O(logn)
- 삽입, 삭제 : O(n)

## 트리 탐색

### 이진 탐색 트리

- 한 노드의 왼쪽 서브트리에 있는 모든 키 값은 그 노드의 키 값보다 작다.
- 한 노드의 오른쪽 서브트리에 있는 모든 키 값은 그 노드의 키 값보다 크다.
- 삽입 : 이진 트리를 탐색하다가 비교할 자식 노드가 없으면 해당 위치에 새로운 노드를 자식 노드로 추가한다. 삽입할 원소가 이미 존재하면 그대로 종료한다.
- 삭제
  1. 자식 노드가 없는 경우 : 삭제되는 노드가 리프 노드이므로 삭제하고 위치 조절은 필요 없다.
     <img src="/assets/img/blog/2024-05-25-search_01.png" style="display:block;margin-top:20px;">
  2. 자식 노드가 하나인 경우 : 자식 노드를 삭제되는 노드의 위치로 올리면서 서브트리 전체도 따라 올린다.
     <img src="/assets/img/blog/2024-05-25-search_02.png" style="display:block;margin-top:20px;">
  3. 자식 노드가 2개인 경우 : 삭제되는 노드의 후속자 노드(바로 다음으로 큰 키값을 가진 노드)를 삭제되는 노드의 위치로 올리고, 후속자 노드의 자식 여부에 따라 1,2 번을 실행한다.
     <img src="/assets/img/blog/2024-05-25-search_03.png" style="display:block;margin-top:20px;">
- 삽입/삭제 시 기존 노드의 이동이 거의 발생하지 않음
- 경사 트리가 만들어지지 않도록 탐색 트리의 좌우 서브트리가 같은 높이를 유지하는 자료구조를 **균형 탐색 트리**라 한다.

#### 시간복잡도

- 트리의 높이에 비례한다. 높이가 h이라면 O(h)
- 탐색, 삽입, 연산
  - 평균 : O(logn)
    - 리프 노드 제외 모든 노드의 차수가 2인 경우 (포화/완전 이진트리)
  - 최악 : O(n)
    - 리프 노드 제외 모든 노드의 차수가 1인 경우 (경사 트리)
  - 경사 트리가 만들어지지 않도록 하면 시간복잡도 O(logn)을 보장한다.

### 2-3-4 트리

<img src="/assets/img/blog/2024-05-25-search_04.png" style="margin-bottom:20px;">

- 다음 성질을 만족하는 **균형 탐색 트리**

  - 2-노드 : 1개의 키와 2개의 자식을 갖는 노드
  - 3-노드 : 2개의 키와 3개의 자식을 갖는 노드
  - 4-노드 : 3개의 키와 4개의 자식을 갖는 노드

- 한 노드의 왼쪽 서브트리에 있는 모든 키 값은 그 노드의 키 값보다 작다.
- 한 노드의 오른쪽 서브트리에 있는 모든 키 값은 그 노드의 키 값보다 크다.

  - 모든 리프 노드의 레벨은 동일하다.

- 삽입 : 트리를 탐색하다가 탐색할 자식 노드가 없으면 현재 리프 노드에 키로 추가한다.
  - 탐색 과정에서 4-노드를 만나면 노드 분할을 우선 수행한다. 4-노드의 가운데 노드를 부모 노드에 추가하고 나머지 노드를 2-노드 2개로 분할한 후 키를 추가한다.
    <img src="/assets/img/blog/2024-05-25-search_05.png" style="display:block;margin-top:20px;">
- 노드 구조가 복잡해서 이진 탐색 트리보다 더 느려질 가능성이 많다.

#### 시간복잡도

- 탐색, 삽입, 연산 : O(logn)

### 레드-블랙 트리

<img src="/assets/img/blog/2024-05-25-search_06.png" style="display:block;margin-bottom:20px;">

- 다음 성질을 만족하는 **균형 탐색 트리**
  1. 모든 노드는 검정이거나 빨강이다.
  1. 루트 노드와 리프 노드는 검정이다. (모든 리프 노드는 NULL 노드이다.)
  1. 빨강 노드의 부모 노드는 항상 검정이다.
  1. 임의의 노드로부터 리프 노드까지의 경로상에는 동일한 개수의 검정 노드가 존재한다.
  1. 한 노드의 왼쪽 서브트리에 있는 모든 키 값은 그 노드의 키 값보다 작다.
  1. 한 노드의 오른쪽 서브트리에 있는 모든 키 값은 그 노드의 키 값보다 크다.
- 두 리프 노드의 레벨 차이가 2배를 넘지 않는다.
- 탐색 연산은 사실상 이진 탐색 트리와 동일하다.
- 삽입 : 삽입할 위치에 원소를 빨간색 노드로 추가하고 2개의 NULL 노드를 자식 노드로 만든다. 만약 삽입한 노드의 부모 노드가 빨강이라면 성질3에 위배되므로 아래 규칙을 적용하여 노드의 구조나 색깔을 조정한다.
  - 규칙1 : 부모 노드의 형제 노드가 빨강인 경우 : 부모 노드, 부모 노드의 형제 노드, 부모 노드의 부모 노드의 색깔을 모두 변경한다.
  - 규칙2 : 부모 노드의 형제 노드가 검정이고, 현재 노드의 키 값이 부모 노드와 부모 노드의 부모 노드의 키 값 사이인 경우 : 현재 노드와 부모노드를 회전(rotate)시킨다.
  - 규칙3 : 부모 노드의 형제 노드가 검정이고, 현재 노드의 키 값보다 부모 노드와 부모 노드의 키 값이 큰 경우(혹은 작은 경우) : 부모 노드와 부모 노드의 부모 노드를 회전시키고 색깔을 변경한다.
- 빨강 노드를 부모 노드와 묶어서 하나의 노드로 표현하면 2-3-4 트리를 이진 탐색 트리로 표현한 것이다.

#### 예시

아래 레드-블랙 트리에 원소 45를 삽입하시오.

<img src="/assets/img/blog/2024-05-25-search_07.png" style="margin-top:20px;">

1. 키 값이 50인 노드의 왼쪽 자식 노드에 추가한다.

<img src="/assets/img/blog/2024-05-25-search_08.png" style="margin-top:20px;">

2. 키 값이 45인 노드와 부모 노드가 빨강이므로 규칙을 이용하여 노드를 조정해야 한다.
   키 값이 45인 노드를 기준으로 부모 노드와 형제 노드가 빨강이므로 규칙1에 의해 부모 노드, 부모 노드의 형제 노드, 부모 노드의 부모 노드의 색깔을 모두 변경한다.

<img src="/assets/img/blog/2024-05-25-search_09.png" style="margin-top:20px;">

3. 키 값이 40인 노드와 부모 노드가 빨강이므로 규칙을 이용하여 노드를 조정해야 한다.
   키 값이 40인 노드를 기준으로 부모 노드의 형제 노드가 검정이고, 현재 노드의 키 값이 부모 노드와 부모 노드의 부모 노드의 키 값 사이이므로 규칙2에 의해 현재 노드와 부모노드를 회전(rotate)시킨다.

<img src="/assets/img/blog/2024-05-25-search_10.png" style="margin-top:20px;">

4. 키 값이 60인 노드와 부모 노드가 빨강이므로 규칙을 이용하여 노드를 조정해야 한다.
   키 값이 60인 노드를 기준으로 부모 노드의 형제 노드가 검정이고, 현재 노드의 키 값보다 부모 노드와 부모 노드의 키 값이 크므로 규칙3에 의해 부모 노드와 부모 노드의 부모 노드를 회전시키고 색깔을 변경한다.

<img src="/assets/img/blog/2024-05-25-search_11.png" style="margin-top:20px;">

#### 시간복잡도

- 탐색, 삽입, 연산 : O(logn)
- 최악의 경우에도 트리의 높이 O(logn)

### B-트리

- 다음 성질을 만족하는 **균형 탐색 트리**
  1. 루트 노드는 1개 이상 2t개 미만의 오름차순으로 정렬된 키를 갖는다. (t는 자연수인 상수이다.)
  1. 루트 노드가 아닌 모든 노드는 (t-1)개 이상 2t개 미만의 오름차순으로 정렬된 키를 갖는다.
  1. 내부 노드는 자신이 가진 키의 개수보다 하나 더 많은 자식을 갖는다.
  1. 한 노드의 왼쪽 서브트리에 있는 모든 키 값은 그 노드의 키 값보다 작다.
  1. 한 노드의 오른쪽 서브트리에 있는 모든 키 값은 그 노드의 키 값보다 크다.
  1. 모든 리프 노드의 레벨은 동일하다.
- 삽입 : (2t-1)개의 키를 갖는 노드에 삽입해야 하는 경우, 이 노드를 (t-1)개의 키를 갖는 2개의 노드와 1개의 키를 갖는 노드로 분할한 뒤 삽입
- 내부 탐색과 외부 탐색에 모두 활용
  - 내부 탐색의 경우 t는 2또는 3 정도의 작은 값으로 지정한다. t가 2면 2-3-4 트리와 동일하다.
  - 외부 탐색의 경우 t를 충분히 크게 지정한다. 한 노드의 크기가 디스크의 한 블록에 저장되도록 한다.

#### 시간복잡도

- 탐색, 삽입, 연산 : O(logn)
