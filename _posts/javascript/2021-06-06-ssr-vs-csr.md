---
title: "서버 사이드 렌더링(SSR) vs 클라이언트 사이드 렌더링(CSR)"
categories: [Javascript]
tags: [javascript, ssr, csr]
---

{:toc .large-only}

### 서버 사이드 렌더링(SSR)

- 사용자가 페이지를 이동할 때마다 서버에서 새로운 페이지를 받아온다.

- 서버가 내용이 담긴 html 파일을 보내면 브라우저가 받아서 렌더링한다.

- 이후 브라우저는 서버로부터 js 파일을 받아 페이지에 적용시킨다.

- 서버로부터 만들어진 html을 받기 때문에 첫 페이지를 보여주는 로딩 속도가 빠르다.

- 페이지 이동 시마다 서버에서 페이지를 불러오므로 서버 과부하가 생길 수 있다.

- html 파일을 불러온 후 js 파일을 불러오기 때문에, 페이지는 렌더링됐지만 js는 아직 적용되지 않는 시간이 생길 수 있다.

<img src="/assets/img/blog/2021-06-06-ssr_vs_csr_01.png">

### 클라이언트 사이드 렌더링(CSR)

- 첫 요청할 때 내용이 비어있는 html 파일을 서버에서 불러온다.

- ajax를 통해 필요한 부분만 서버에 요청하고, dom을 그리는 역할은 클라이언트 측에서 직접 렌더링한다.

- 번들링 된 js 파일을 불러온 후에야 html 문서에 dom을 그릴 수 있기 때문에 처음 페이지가 보여지는 시간이 느리다.

- js 파일을 하나로 번들링하면 크기가 커져 렌더링 속도가 더 느려지는데, code splitting 등을 통해 js 파일을 쪼개면 성능을 향상시킬 수 있다.

ex) React.js, Vue.js 등의 SPA

<img src="/assets/img/blog/2021-06-06-ssr_vs_csr_03.png" style="margin:30px 0">

## 전체적인 과정

<img src="/assets/img/blog/2021-06-06-ssr_vs_csr_04.png" style="margin:30px 0">

### 서버 사이드 렌더링과 클라이언트 사이드 렌더링의 차이

서버 사이드 렌더링과 클라이언트 사이드 렌더링의 차이는 **어디서 화면에 보일 페이지의 내용을 그리느냐의 차이**이다.

서버 사이드 렌더링은 서버에서 페이지의 내용을 다 그려서 브라우저로 던져주고, 클라이언트 사이드 렌더링은 페이지의 내용을 브라우저에서 그리게 된다.

이 **그린다**는 표현 때문에 SSR 방식에서 렌더 트리를 생성하는 시점이 헷갈렸는데, 서버에서 렌더 트리를 생성해서 보내준다는 뜻이 아니라 CSR과 달리 html이 완성된 채로 오는 것을 의미한다.

CSR에서 js를 통해 요소들을 dom에 집어넣는 것을 **그린다**고 표현하기 때문에 SSR에서는 페이지를 그려서 온다고 표현해서 헷갈린 것.

결론적으로 렌더 트리는 브라우저의 렌더링 엔진이 생성한다.

<img src="/assets/img/blog/2021-06-06-ssr_vs_csr_02.png">

<br/>

| 구분 | 서버 사이드 렌더링                                                                                                 | 클라이언트 사이드 렌더링                                                                            |
| ---- | ------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------- |
| 장점 | - 검색엔진 최적화(SEO) 가능<br/>- 렌더링된 html을 클라이언트에 전달해주기 때문에 초기 로딩 속도가 빠름 (성능 개선) | - 트래픽 감소<br/>- 클라이언트 측에서 렌더링하기 때문에 서버 측에서 렌더링하는 것보다 빠른 인터렉션 |
| 단점 | - 프로젝트의 복잡도<br/>- 페이지 요청마다 새로고침 발생<br/>- 서버 렌더링에 따른 부하 발생                         | - 초기 구동속도가 느림<br>- 검색엔진 최적화(SEO)가 어렵다.                                          |

## 참고사이트

[서버사이드 렌더링(ssr) & 클라이언트 사이드 렌더링(csr)](https://velog.io/@ash3767/%EC%84%9C%EB%B2%84%EC%82%AC%EC%9D%B4%EB%93%9C-%EB%A0%8C%EB%8D%94%EB%A7%81-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%82%AC%EC%9D%B4%EB%93%9C-%EB%A0%8C%EB%8D%94%EB%A7%81)<br/>
[서버사이드렌더링 & 클라이언트사이드렌더링](https://velog.io/@zansol/%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0-%EC%84%9C%EB%B2%84%EC%82%AC%EC%9D%B4%EB%93%9C%EB%A0%8C%EB%8D%94%EB%A7%81SSR-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%82%AC%EC%9D%B4%EB%93%9C%EB%A0%8C%EB%8D%94%EB%A7%81CSR)<br/>
[서버 사이드 렌더링(SSR), 클라이언트 사이드 렌더링(CSR)](https://brownbears.tistory.com/411)<br/>
[SSR 개념 이해와 Next.js로 실습까지 해보는 SSR 환경 구축하기](https://velog.io/@jeff0720/Next.js-%EA%B0%9C%EB%85%90-%EC%9D%B4%ED%95%B4-%EB%B6%80%ED%84%B0-%EC%8B%A4%EC%8A%B5%EA%B9%8C%EC%A7%80-%ED%95%B4%EB%B3%B4%EB%8A%94-SSR-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95)<br/>
[[Web][Performance][Chrome] 웹 프론트의 성능을 보자(2) - 웹페이지가 로딩되는 순서 보기](https://kamang-it.tistory.com/m/entry/WebPerformanceChrome-%EC%9B%B9-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%9D%98-%EC%84%B1%EB%8A%A5%EC%9D%84-%EB%B3%B4%EC%9E%902-%EC%9B%B9%ED%8E%98%EC%9D%B4%EC%A7%80%EA%B0%80-%EB%A1%9C%EB%94%A9%EB%90%98%EB%8A%94-%EC%88%9C%EC%84%9C-%EB%B3%B4%EA%B8%B0)
