---
title: "[데이터베이스 시스템] 트랜잭션"
categories: [Backend]
tags: [sql, database]
---

{:toc .large-only}

## 트랜잭션

- 데이터베이스를 조작하기 위한 하나의 논리적 단위를 이루는 일련의 연산의 집합
- 데이터베이스를 사용하여 처리하는 작업을 하나의 묶음으로 인식하여 묶음 단위로 실행되도록 정의한 개념

## ACID 특성

### 원자성(Atomicity)

한 트랜잭션에 포함된 모든 연산은 완전히 수행되거나 수행되지 않아야 한다.

<img src="/assets/img/blog/2024-06-09-transaction_01.png" style="margin-top:15px;">

### 일관성(Consistency)

한 트랜잭션이 수행되기 전과 후에 데이터베이스가 일관된 상태를 유지해야 한다.

<img src="/assets/img/blog/2024-06-09-transaction_02.png" style="margin-top:15px;">

### 고립성(Isolation)

한 트랜잭션이 데이터베이스를 갱신하는 동안 다른 트랜잭션에 의해 방해받지 않아야 한다.

<img src="/assets/img/blog/2024-06-09-transaction_03.png" style="margin-top:15px;">

### 지속성(Durability)

완료된 트랜잭션의 결과는 어떠한 시스템의 장애에도 데이터베이스에 반영되어야 한다.

<img src="/assets/img/blog/2024-06-09-transaction_04.png" style="margin-top:15px;">

## 트랜잭션 연산자

- Read(X) : 데이터베이스에서 데이터 X를 읽고, 트랜잭션이 실행되는 메모리 변수 X에 값을 저장
- Write(X) : 트랜잭션이 실행되는 메모리에 있는 변수 X의 값을 데이터베이스에 저장
- Commit : 트랜잭션 연산에 의해 갱신된 데이터 항목의 값을 데이터베이스에 반영시키고 지속성을 확보
- Rollback : 트랜잭션이 중단되기 이전까지 수행한 연산에 의해 갱신된 모든 데이터 항목의 값을 무효화하여 일관성을 확보

## 트랜잭션의 5가지 상태 변화

<img src="/assets/img/blog/2024-06-09-transaction_05.png" style="margin-botom:15px;">

- 동작 : 트랜잭션이 시작을 준비 또는 실행 중인 상태
- 부분 커밋 : 마지막 연산을 실행한 직후의 상태
- 커밋 : 모든 실행이 성공적으로 완료된 상태
- 실패 : 실행이 정상적으로 진행될 수 없는 상태
- 중단 : 실행 실패로 롤백되고 시작 이전의 상태로 환원된 상태

## 트랜잭션의 동시성

- 트랜잭션 동시 실행 시 처리률과 자원 이용률을 향상하고 트랜잭션 대기 시간을 감소시킬 수 있다.
- 동시성 제어 : 다수의 트랜잭션이 동시에 실행되어도 일관성을 유지할 수 있는 기법
- 스케줄 : 트랜잭션에 포함된 연산의 실제 실행 순서
- 직렬 스케줄 : 각 트랜잭션의 모든 연산을 순차적으로 실행되는 스케줄
- 병렬 스케줄 : 하나의 트랜잭션이 완료되기 전에 다른 트랜잭션이 실행되는 스케줄 (비순차적)
  - 일관성의 훼손이 발생 가능하다.

### 직렬 가능 스케줄

- 트랜잭션 간 연산 순서를 교환하여 직렬 스케줄과 동등하게 변환이 가능한 스케줄
- 일관성이 훼손되는 현상(충돌)이 발생하지 않는 선에서 Read와 Write 연산 순서를 교환

#### 충돌 동등

특정 스케줄 𝑆에서 충돌이 일어나지 않는 연산의 순서를 바꿔 스케줄 𝑆′으로 변환이 가능한 상태

<img src="/assets/img/blog/2024-06-09-transaction_06.png" style="margin:20px 0;">

위 그림에서 기존 상태에서 Write(A)와 Read(A) 연산 순서를 교환하면 충돌이 발생하지만, Write(B)와 Write(A)를 교환하면 충돌이 발생하지 않는다.

즉, 같은 데이터에 대한 연산을 교환하는 것은 충돌을 발생시키지만, 서로 다른 데이터에 대한 연산을 교환하는 것은 충돌을 발생시키지 않는다.

#### 충돌 직렬성

충돌 동등을 그대로 유지하면서 연산을 교환하면 직렬 스케줄의 연산과 동등하게 변환이 가능한 스케줄

<img src="/assets/img/blog/2024-06-09-transaction_07.png" style="margin-top:15px;">

## 트랜잭션의 회복

- 원자성을 보장하기 위해 트랜잭션 실패 시 실행된 모든 연산을 실행 이전 상태로 복원하는 기법

### 회복 불가능한 스케줄

<img src="/assets/img/blog/2024-06-09-transaction_08.png" style="margin-bottom:15px;">

𝑇6가 𝑇5가 기록한 𝐴를 읽고 커밋한 상태에서 커밋한 𝑇6는 롤백 불가능

### 회복 가능한 스케줄

- 𝑇𝑖와 𝑇𝑗에 대해, 𝑇𝑖가 기록한 데이터를 𝑇𝑗가 읽을 때, **𝑇𝑖의 커밋이 𝑇𝑗 보다 먼저 나타나는 스케줄**
- 대신 연쇄적 롤백을 유발할 수 있다.

<img src="/assets/img/blog/2024-06-09-transaction_09.png" style="margin-top:15px;">

### 비연쇄적 스케줄

- 연쇄적 롤백을 방지하기 위해 연쇄적이지 않은 스케줄로 구성된 스케줄
- 𝑇𝑖가 기록한 데이터를 읽을 때 **𝑇𝑖의 커밋이 𝑇𝑗의 읽기 연산보다 먼저 나타나는 스케줄**

<img src="/assets/img/blog/2024-06-09-transaction_10.png" style="margin-top:15px;">
