---
title: "[컴퓨터구조] 컴퓨터 명령어"
categories: [Computer Science]
tags: [cs]
---

{:toc .large-only}

## 컴퓨터 명령어

- 컴퓨터 명령어는 컴퓨터가 수행해야 하는 일을 나타내기 위한 비트들의 집합으로 일정한 형식을 가진다.
- 명령어의 세트를 명령어 집합이라고 한다.
- 동일 계열의 컴퓨터는 같은 명령어 집합을 사용한다.
- 명령어와 명령어 수행에 필요한 데이터는 주기억장치에 저장되어 있고, 이것을 중앙처리장치가 하나씩 순차적으로 수행한다.
- 컴퓨터의 제어장치는 기억장치에 저장된 명령어와 데이터를 읽어서 2진 코드를 해석한 후, 명령어 수행을 위한 제어신호를 제공한다.

<img src="/assets/img/blog/2024-09-13-computer2_01.png" style="margin-top:10px" />

### 명령어의 구성

- 필드라는 비트그룹으로 이루어지며, 연산코드와 오퍼랜드 필드로 구성된다.
  - 연산코드 필드: 처리해야 할 연산의 종류
  - 오퍼랜드 필드: 처리할 대상 데이터 또는 데이터의 주소

<img src="/assets/img/blog/2024-09-13-computer2_02.png" style="margin:10px 0" />

### 명령어의 기능

- 함수연산 기능: 덧셈, 시프트, 보수 등 산술연산과 AND, OR, NOT 등의 논리연산 수행 기능
- 정보전달 기능: 레지스터들 사이의 정보전달 기능과 중앙처리장치와 주기억장치 사이의 정보전달 기능
- 순서제어 기능: 조건 분기와 무조건 분기 등을 통해 명령어의 수행 순서를 제어하는 기능
- 입출력 기능: 주기억장치와 입출력장치 사이의 정보 이동 기능

## 명령어의 형식

- 컴퓨터 명령어는 컴퓨터 내부구조에 따라 여러 형식으로 나타난다.
- 명령어 형식은 오퍼랜드의 기억장소에 따른 형식과 오퍼랜드의 수에 따른 형식으로 분류된다.

### 오퍼랜드의 기억장소에 따른 명령어 형식

#### 누산기를 이용하는 명령어 형식

<img src="/assets/img/blog/2024-09-13-computer2_03.png" style="margin-bottom:20px" />

- 누산기를 가진 컴퓨터 구조에서 사용되는 형식
- 누산기(AC): 명령어가 수행될 때 오퍼랜드를 기억시키는 레지스터
- **1-주소 명령어**로서 하나의 기억장치 주소 필드를 사용
- `ADD X`
  - AC ← AC+M[X]
  - X: 기억장치에 있는 오퍼랜드의 주소
  - 누산기에 있는 내용과 기억장치 주소 X에 있는 내용을 더해서 누산기로 전송
- `LOAD X`
  - AC ← M[X]
  - 기억장치 주소 X에 있는 내용을 누산기로 적재
- `STORE X`
  - M[X] ← AC
  - 누산기의 내용을 기억장치 주소 X에 저장

#### 다중 레지스터를 이용한 명령어 형식

<img src="/assets/img/blog/2024-09-13-computer2_04.png" style="margin-bottom:20px" />

- 중앙처리장치 내에 여러 개의 레지스터를 가지고 있는 컴퓨터 구조에서 사용되는 형식
- **2-주소 또는 3-주소 명령어** 사용
- `ADD R1, R2, R3`
  - R3 ← R1 + R2
  - R: 레지스터
  - 세 개의 레지스터를 사용하는 경우 레지스터 R1의 내용과 레지스터 R2의 내용을 더해서 레지스터 R3에 전송
- `ADD R1, R2`
  - R2 ← R1 + R2
  - 두 개의 레지스터를 사용하는 경우 레지스터 R1의 내용과 레지스터 R2의 내용을 더해서 레지스터 R2에 전송
- `MOVE R1, R2`
  - R2 ← R1
  - 레지스터 R1의 내용을 레지스터 R2로 전송
- `LOAD X, R1`
  - R1 ← M[X]
  - 기억장치 주소 X에 있는 내용을 레지스터 R1에 적재
- `STORE R1, X`
  - M[X] ← R1
  - 레지스터 R1의 내용을 기억장치 주소 X에 저장

#### 스택 구조를 이용한 명령어 형식

<img src="/assets/img/blog/2024-09-13-computer2_05.png" style="margin-bottom:20px" />

- 스택을 가진 컴퓨터 구조에서 사용되는 형식
- 오퍼랜드들과 연산의 결과를 기억장치 스택에 기억시키는 구조
- 스택 구조에서 함수연산기능의 명령어 형식(ADD, MUL)은 **0-주소 명령어**로서 주소 필드를 표기하지 않아도 된다. (데이터 전송 명령어 형식은 하나의 주소 사용)
- `ADD`
  - TOS ← TOS + TOS-1
  - TOS: Top Of Stack (스택의 맨 위)
  - TOS-1: TOS의 아래 스택
  - 기억장치 스택의 맨 위의 내용과 그 아래의 내용을 더해서 스택의 맨 위로 전송
- `PUSH X`
  - TOS ← M[X]
  - 기억장치 주소 X에 저장된 내용을 기억장치 스택의 맨 위로 전송
- `POP X`
  - M[X] ← TOS
  - 기억장치 스택의 맨 위에 있는 내용을 기억장치 주소 X로 전송

### 오퍼랜드의 수에 따른 명령어 형식

#### 3-주소 명령어

- 오퍼랜드가 3개인 명령어 형식
- 장점: 산술식을 프로그램화할 때 총 명령어 수가 줄어듬
- 단점: 2진 코드화 했을 때 비트 수가 다른 주소 명령어 형식보다 많이 필요
- ex) 산술식 X = (A+B)\*C 에 대해 3-주소 명령어를 이용한 프로그램
  - `ADD A, B, R1` ; R1 ← M(A) + M(B)
  - `MUL R1, C, X` ; M(X) ← R1 \* M(C)

#### 2-주소 명령어

- 오퍼랜드가 2개인 명령어 형식
- 장점: 3-주소 명령어에 비해 명령어의 길이가 짧음
- 단점: 같은 내용을 수행하기 위해 수행해야 하는 명령어가 많아짐
- ex) 산술식 X = (A+B)\*C 에 대해 2-주소 명령어를 이용한 프로그램
  - `LOAD A, R1` ; R1 ← M(A)
  - `ADD B, R1` ; R1 ← R1 + M(B)
  - `MUL C, R1` ; R1 ← R1 \* M(C)
  - `STORE R1, X` ; M(X) ← R1

#### 1-주소 명령어

- 오퍼랜드가 1개인 명령어 형식
- ex) 산술식 X = (A+B)\*C 에 대해 1-주소 명령어를 이용한 프로그램
  - `LOAD A` ; AC ← M(A)
  - `ADD B` ; AC ← AC + M(B)
  - `STORE X` ; M(X) ← AC
  - `LOAD C` ; AC ← M(C)
  - `MUL X` ; AC ← AC \* M(X)
  - `STORE X` ; M(X) ← AC

#### 0-주소 명령어

- 주소 필드를 사용하지 않는 명령어 형식
- 기억장치 스택 사용
- 장점: 명령어의 길이가 매우 짧아서 기억공간을 적게 차지
- 단점: 많은 양의 정보가 스택과 기억장치 사이를 이동하게 되어 비효율적
- ex) 산술식 X = (A+B)\*C 에 대해 0-주소 명령어를 이용한 프로그램
  - `PUSH A` ; TOS ← M(A)
  - `PUSH B` ; TOS ← M(B)
  - `ADD` ; TOS ← TOS + TOS-1
  - `PUSH C` ; TOS ← M(C)
  - `MUL` ; TOS ← TOS \* TOS-1
  - `POP X` ; M(X) ← TOS

## 주소지정방식

### 명령어 주소지정방식

- 명령어의 오퍼랜드를 변경하거나 해석하는 규칙을 지정
- 주소지정방식을 사용하면 명령어의 수를 효과적으로 줄일 수 있음
- **유효주소**: 주소지정방식의 각 규칙에 의해 정해지는 **오퍼랜드의 실제 주소**

<img src="/assets/img/blog/2024-09-13-computer2_06.png" style="margin-top:20px" />

### 주소지정방식의 종류

#### 즉치 주소지정방식

- 명령어의 오퍼랜드 필드에 실제 사용할 데이터가 저장되어 있음
- `LDA #NBR` ; AC ← NBR
  - NBR: 오퍼랜드

#### 직접 주소지정방식

- 명령어의 주소필드에 오퍼랜드의 주소를 직접 저장
- `LDA ADRS` ; AC ← M[ADRS]
  - ADRS: 주소

#### 간접 주소지정방식

- 명령어의 주소필드에 유효주소가 저장되어 있는 기억장치 주소를 저장
- `LDA [ADRS]` ; AC ← M[M[ADRS]]

#### 레지스터 주소지정방식

- 오퍼랜드 필드에 레지스터 번호 저장
- 레지스터에 실제 사용할 오퍼랜드 데이터가 들어있음
- 유효번호가 존재하지 않는다.
- `LDA R1` ; AC ← R1

#### 레지스터 간접 주소지정방식

- 레지스터에 실제 오퍼랜드가 저장된 기억장치의 주소를 저장
- `LDA (R1)` ; AC ← M[R1]

#### 상대 주소지정방식

- 특정 레지스터의 내용에 명령어 주소필드 값을 더하는 방식
- 특정 레지스터로 프로그램 카운터(PC)를 주로 사용
- PC는 프로그램의 시작 주소였다가 프로그램이 수행되면 다음 주소로 변경된다.
- `LDA $ADRS` ; AC ← M[ADRS+PC]
  - 유효주소 = 명령어 주소부분의 내용 + PC의 내용

#### 인덱스된 주소지정방식

- 인덱스 레지스터의 내용을 명령어 주소 부분에 더해서 유효주소를 얻는 방식
- `LDA ADRS(R1)` ; AC ← M[ADRS+R1]
  - 유효주소 = 명령어 주소부분의 내용 + 인덱스 레지스터의 내용

### 주소지정방식 요약

<img src="/assets/img/blog/2024-09-13-computer2_07.png" style="margin-bottom:20px" />

| 주소지정방식      | 기호표기       | 레지스터 전송   | 유효주소 | AC  |
| ----------------- | -------------- | --------------- | :------: | :-: |
| 즉치주소          | `LDA #NBR`     | AC ← NBR        |   251    | 500 |
| 직접주소          | `LDA ADRS`     | AC ← M[ADRS]    |   500    | 800 |
| 간접주소          | `LDA [ADRS]`   | AC ← M[M[ADRS]] |   800    | 300 |
| 상대주소          | `LDA $ADRS`    | AC ← M[ADRS+PC] |   752    | 600 |
| 인덱스주소        | `LDA ADRS(R1)` | AC ← M[ADRS+R1] |   900    | 200 |
| 레지스터 주소     | `LDA R1`       | AC ← R1         |    -     | 400 |
| 레지스터 간접주소 | `LDA (R1)`     | AC ← M[R1]      |   400    | 700 |
